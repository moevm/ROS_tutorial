#!/usr/bin/env python3
import sys
import signal
import rospkg
import rospy
from math import pi, sin, cos, sqrt
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist, Pose
#Использовать pyqt5 вместо python_qt_biding для упрощения поиска методов
from PyQt5 import QtCore, QtWidgets, QtGui
# from python_qt_binding import QtCore, QtWidgets, QtGui
from ros_tutorial.srv import Kill, KillResponse, SetPose, SetPoseResponse, \
    Spawn, SpawnResponse, SetWall, SetWallResponse, OnOffLaser, OnOffLaserResponse
from ros_tutorial.msg import ObjectsArray, ObjectOnScene

#при спавне робота или стены, проверять, что нет пересечений с другими роботами
#добавить линии, отображающие координаты

HEIGHT = 500
WIDTH = 500
WIDTH_OFFSET = 50
HEIGHT_OFFSET = 50
VIEW_H_OFFSET = 20
VIEW_W_OFFSET = 20


class Scaner():
    # set distance to -1 so range is not limited
    #TODO add service for change color, type of render scan(dots or lines)
    def __init__(self, distance = -1, start_angle=0, end_angle=360, angle_delta=1, parent_id='robot1') -> None:
        self.distance = distance
        self.start_angle=start_angle
        self.end_angle=end_angle
        self.angle_delta = angle_delta
        self.parent_id = parent_id

    def set_objects(self, objects):
        self.objects = objects

    def get_distance_to_object(self, x, y, angle, robot_offset, curr):
        near = self.distance
        if near == -1:
            near = 1000
        point1 = {'x': x + (robot_offset) * cos(angle * pi / 180), 'y': y + robot_offset * sin(angle * pi / 180)}
        vector = {'x1': point1['x'], 'y1': point1['y'], 'x2': x + (near) * cos(angle * pi / 180), 'y2': y + near * sin(angle * pi / 180)}
        closest_point = {}
        for i in self.objects:
            #TODO поправить отображение лазера на спрайте робота
            if i.type == 'robot' and i.name == self.parent_id:
                continue
            for j in range((len(i.points) - 3)):
                def findIntersection(x1,y1,x2,y2,x3,y3,x4,y4):
                    try:
                        ua = ((x4 - x3)*(y1 - y3) - (y4 - y3)*(x1 - x3))/((y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1))
                        ub = ((x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3))/((y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1))
                        if 0 <= ua <= 1 and 0 <= ub <= 1:
                            return {'x': x1 + ua * (x2 - x1), 'y': y1 + ua * (y2 - y1)}
                        return None
                    except ZeroDivisionError:
                        return None

                point = findIntersection(i.points[j],i.points[j+1], i.points[j+2],i.points[j+3],
                                         vector['x1'], vector['y1'], vector['x2'], vector['y2'])
                if point:
                    new_dist = sqrt((point['x'] - x) ** 2 + (point['y'] - y) ** 2)
                    if new_dist < near:
                        closest_point['x'] = point['x']
                        closest_point['y'] = point['y']
                        near = new_dist
        return {'point1': point1, 'point2': closest_point}

    def get_laser_points(self, x, y, robot_offset, direction):
        self.points = []
        for current_angle in range(self.start_angle, self.end_angle, self.angle_delta):
            point = self.get_distance_to_object(x, y, direction + current_angle, robot_offset, current_angle)
            self.points.append(point)
        return self.points

        


class Robot():
    def __init__(self, name='robot1', x=0, y=0, angle=0, frame=None, laser_on=False) -> None:
        self.name = name
        self.x = x
        self.y = y
        self.angle = 0
        self.frame = frame
        self.init_topics()
        self.scan = Scaner(parent_id=self.name)
        self.points = []
        self.draw_laser = laser_on

    #добавить сервис для on/off лазера, сервис изменения цвета лазера, сервис изменения линии на точку
    def set_services(self, set_pose, kill):
        self.set_pose = set_pose
        self.kill = kill
        self.on_off_laser = rospy.Service(f'{self.name}/on_off_laser', OnOffLaser, self.change_draw_state)

    def change_draw_state(self, msg):
        self.draw_laser = not self.draw_laser
        return OnOffLaserResponse(self.draw_laser)

    def shutdown_service(self):
        self.set_pose.shutdown()
        self.kill.shutdown()
        self.on_off_laser.shutdown()
        
    def move(self, data):                
        self.angle += data.angular.z
        if self.angle >= 360:
            self.angle -= 360
        elif  self.angle < 0:
            self.angle += 360

        dx = data.linear.x * cos(self.angle * pi / 180)
        dy = data.linear.x * sin(self.angle * pi / 180)        
        #TODO физика объектов

        if abs(self.x + dx) < WIDTH / 2 - self.frame.pixmap().width():
            self.x += dx
        else:
            rospy.logwarn('i hit the wall!')
        if abs(self.y + dy) < HEIGHT / 2 - self.frame.pixmap().height():    
            self.y += dy
        else:
            rospy.logwarn('i hit the wall!')
        

    def init_topics(self):
        self.cmd_vel = rospy.Subscriber(f'{self.name}/cmd_vel', Twist, callback=self.move)
        self.pose = rospy.Publisher(f'{self.name}/pose', Pose, queue_size=10)
        self.laser_scan_publisher = rospy.Publisher(f'{self.name}/laser_scan', LaserScan, queue_size=10)
        # TODO убрать баг с get_name, который возвращает unnamed
        # self.object_subscriber = rospy.Subscriber(f'{rospy.get_name()}/objects', ObjectsArray, callback=self.whats_around_me)
        self.object_subscriber = rospy.Subscriber(f'robot_node/objects', ObjectsArray, callback=self.whats_around_me)

    def publish(self):
        pose_msg = Pose()
        pose_msg.position.x = self.x
        pose_msg.position.y = self.y
        pose_msg.orientation.z = self.angle
        self.pose.publish(pose_msg)

        scan_msg = self.fill_scan_msg(LaserScan())
        self.laser_scan_publisher.publish(scan_msg)

    def fill_scan_msg(self, msg):
        # TODO fill msg
        return msg

    def shutdown_topics(self):
        self.cmd_vel.unregister()
        self.pose.unregister()

    def whats_around_me(self, msg):
        self.scan.set_objects(msg.data)
        self.points = self.scan.get_laser_points(self.x, self.y, robot_offset=self.frame.boundingRect().height(), direction=self.angle)
            

class Ui_Form(QtWidgets.QWidget):
    def __init__(self):
        super(Ui_Form, self).__init__()
        self._timer = QtCore.QTimer(self)
        self._timer.setInterval(10)
        self._timer.timeout.connect(self.onUpdate)
        self._timer.start()

        self.width = WIDTH + WIDTH_OFFSET
        self.height = HEIGHT + HEIGHT_OFFSET
        self.setupUi(self)

        self.robots_dict = {}
        self.scene = QtWidgets.QGraphicsScene()
        self.scene.clearFocus()
        self.walls = []
        self.laser_polygons = []

        r = rospkg.RosPack()
        self.sprite_path = f'{r.get_path("ros_tutorial")}/resource/robot.png'
                
        self.view = QtWidgets.QGraphicsView(self.scene, self)
        transform = QtGui.QTransform.fromScale(1.0, -1.0)
        self.view.setTransform(transform)
        self.view.setFixedSize(self.width, self.height)
        self.view.setSceneRect(-self.width/2 + VIEW_W_OFFSET, -self.height/2 + VIEW_H_OFFSET, self.width - 2*VIEW_W_OFFSET, self.height - 2*VIEW_H_OFFSET)
        
        self.robots_dict.update({'robot1': Robot(x=0, y=0, laser_on=True)})
        # self.robots_dict.update({'robot2': Robot(name='robot2', x=50, y=50, angle=pi/4)})
        
        self.init_ros()
        self.redPen = QtGui.QPen(QtGui.QColor(255, 0, 0))
        self.blackPen = QtGui.QPen(QtGui.QColor(0, 0, 0))
        self.blackPen.setWidth(1)
        self.scene.addLine(-WIDTH/2, -HEIGHT/2, -WIDTH/2, HEIGHT/2, self.blackPen)
        self.scene.addLine(-WIDTH/2, HEIGHT/2, WIDTH/2, HEIGHT/2, self.blackPen)
        self.scene.addLine(WIDTH/2, -HEIGHT/2, WIDTH/2, HEIGHT/2, self.blackPen)
        self.scene.addLine(-WIDTH/2, -HEIGHT/2, WIDTH/2, -HEIGHT/2, self.blackPen)

        #переделать добавление объектов через rosparam
        self.scene.addLine(-100, -100, 200, -100, self.blackPen)
        self.scene.addLine(-100, 150, 200, 100, self.blackPen)
        self.scene.addLine(-150, 50, -25, -50, self.blackPen)


    def do_close(self):
        self.close()

    def init_ros(self):
        self.node_name = 'robot_node'
        rospy.init_node(self.node_name)
        rospy.Service(f'/{self.node_name}/spawn', Spawn, self.spawn)
        rospy.Service(f'/{self.node_name}/set_wall', SetWall, self.set_wall)
        self.objects_publisher = rospy.Publisher(f'/{self.node_name}/objects', ObjectsArray, queue_size=10)
        #TODO think - добавление новых роботов через rosparam
        self.init_service('robot1')
        # self.init_service('robot2')

    # TODO подумать над переносом инициализации сервисов для робота в класс робота
    def init_service(self, name):
        self.robots_dict[name].set_services(
            set_pose=rospy.Service(f'/{name}/set_pose', SetPose, self.get_teleport_func(name)),
            kill = rospy.Service(f'/{name}/kill', Kill, self.get_kill(name))
        )

    def set_wall(self, req):
        # TODO need to debug. fix timer error - добавление нового элемента, и для отрисовки лазера на новых объектах
        new_wall = self.scene.addLine(req.x1, req.y1, req.x2, req.y2, self.blackPen)
        self.walls.append(new_wall)
        self.onUpdate()
        return SetWallResponse(f'{req.x1} {req.y1} {req.x2} {req.y2}')

    def get_teleport_func(self, name):
        def set_pose(req):
            robot = self.robots_dict[name]
            if self.is_on_field(req.pose):
                robot.move(req.pose)
                return SetPoseResponse(f'x: {req.pose.linear.x}, y: {req.pose.linear.y}, angle: {req.pose.angular.z}')
            else:
                return SetPoseResponse('Out of border!')
        return set_pose

    def spawn(self, req):
        name = req.name
        if req.name == '':
            return SpawnResponse("Robot name must be not empty!")
        if name in self.robots_dict:
            return SpawnResponse('Robot with this name already exits!')
        new_robot = Robot(name=name, x=req.x, y=req.y, angle=req.angle)
        self.robots_dict.update({name: new_robot})
        self.init_service(name)
        return SpawnResponse(name)

    def is_on_field(self, pose):
        if abs(pose.linear.x) < self.width / 2 and abs(pose.linear.y) < self.height / 2:
            return True
        return False
    
    def get_kill(self, name):
        def kill(req):
            self.scene.removeItem(self.robots_dict[name].frame)
            self.robots_dict[name].shutdown_service()
            self.robots_dict[name].shutdown_topics()
            self.robots_dict.pop(name)
            return KillResponse(name)
        return kill

    def onUpdate(self):
        for i in self.laser_polygons:
            self.scene.removeItem(i)
        self.laser_polygons.clear()
        msg = ObjectsArray()
        # get walls point for laser
        for item in self.scene.items():
            newObject = ObjectOnScene()
            if item.type() == 6:
                newObject.type = 'wall'
                newObject.points = [item.line().x1(), item.line().y1(), item.line().x2(), item.line().y2()]
                msg.data.append(newObject)
        
        for key, value in self.robots_dict.items():
            # drawing robot
            if value.frame is None:
                image = QtGui.QImage(self.sprite_path)
                #TODO корректное масштабирование спрайта
                # image = image.scaled(image.size()*2, aspectRatioMode=QtCore.Qt.KeepAspectRatioByExpanding, transformMode=QtCore.Qt.FastTransformation)
                value.frame = QtWidgets.QGraphicsPixmapItem(QtGui.QPixmap.fromImage(image).transformed(QtGui.QTransform().rotate(90)))
                value.frame.setScale(2)
                self.scene.addItem(value.frame)
            value.frame.setOffset(value.x - value.frame.pixmap().width()/2, value.y - value.frame.pixmap().height()/2)
            value.frame.setTransformOriginPoint(value.x, value.y)
            value.frame.setRotation(value.angle)
            value.publish()
            # drawing laser_scan
            if value.draw_laser:
                for i in value.points:
                    if i['point2'] == {}:
                        continue
                    line = self.scene.addPolygon(QtGui.QPolygonF([QtCore.QPointF(i['point1']['x'], i['point1']['y']), QtCore.QPointF(i['point2']['x'], i['point2']['y'])]), self.redPen)
                    self.laser_polygons.append(line)

            # get robot points for laser
            newObject = ObjectOnScene()
            newObject.type = 'robot'
            newObject.name = value.name
            rect = value.frame.boundingRect()
            newObject.points = [rect.topLeft().x() , rect.topLeft().y(),
                                rect.topRight().x(), rect.topRight().y(),
                                rect.bottomLeft().x(), rect.bottomLeft().y(),
                                rect.bottomRight().x(), rect.bottomRight().y(),
            ]
            #TODO проверить границы объекта, чтобы норамльно отрисовывалось
            # newObject.points = list(map(lambda x: x * 0.8, newObject.points))
            msg.data.append(newObject)
        self.objects_publisher.publish(msg)
            

    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.setFixedSize(self.width, self.height)
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))


def handler(*args):
    QtWidgets.QApplication.quit()

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    signal.signal(signal.SIGINT, handler)
    timer = QtCore.QTimer()
    timer.start(200)
    timer.timeout.connect(lambda: None)
    pyShow = Ui_Form()
    pyShow.show()
    sys.exit(app.exec_())